%{
#include <iostream>
#include <string>
#include <memory>
#include <vector>
#include "memc.hpp"
#include "structs.hpp"
#include "code.hpp"
#include <exception>

int yylex();
int yyparse();
void yyerror(std::string er);
void yyabort();
//extern FILE *yyin;
extern int yylineno;

std::shared_ptr<MemoryController> vars = std::make_shared<MemoryController>();
std::shared_ptr<Coder> code = std::make_shared<Coder>(vars);

%}

%union {
  std::string * str;
  long long number;
}
//Tokens
//%start program
%token <str> DECLARE BEGINA END
%token <str> IF WHILE DO
%token <str> FOR 
%token <str> THEN ELSE ENDIF FROM TO DOWNTO ENDFOR ENDWHILE ENDDO
%token <str> READ WRITE       
%token <str> LE GE LEQ GEQ EQ NEQ
%token <str> ASSIGN
%token <str> ERROR
%token <str> pidentifier
%token <number> num


//Types
%start program
%type <number> value
%type <number> identifier //address of p
%type <str> condition
//%type <string> declarations
//%type <string> commands
//%type <string> command
%type <number> expression

//Operators precedence
%left PLUS MINUS
%left TIMES DIV MOD
%%      

program:        DECLARE declarations BEGINA commands END { vars->printAll(); code->printVM();}                                                   
                |
                BEGINA commands END 
;

declarations:   declarations ',' pidentifier                { auto pid = $3; code->declareVariable(*pid); }
                | declarations ',' pidentifier '(' num ':' num ')'    
                {
                  auto pid = $3; auto beg = $5; auto end = $7; 
                  try{
                    code->declareArray(*pid,beg,end);
                  }catch(std::runtime_error & err){
                    yyerror(err.what());
                    YYABORT;
                  }
                }                                          
                | pidentifier                               { auto pid = $1; code->declareVariable(*pid); }
                | pidentifier '('num ':' num ')'  
                {
                  auto pid = $1; auto beg = $3; auto end = $5;
                  try{
                    code->declareArray(*pid,beg,end);
                  }catch(std::runtime_error & err){
                    yyerror(err.what());
                    YYABORT;
                  }
                }
;

commands:       commands command
                | command       
;


command:        identifier ASSIGN expression ';'         { auto index = $1; auto value = $3; code->assignValueToVar(index,value); }                                                       

                
                | IF condition THEN commands                                                             
                  ELSE commands ENDIF                                                                

                | IF condition THEN commands ENDIF                                                  

                | WHILE condition DO                                                                                                                                                             
                  commands ENDWHILE                                                        

                | DO                                                                    
                  commands WHILE condition ENDDO                                        
                                                                                        
                | FOR pidentifier FROM value TO value DO                                
                        commands 
                  ENDFOR              

                | FOR pidentifier FROM value DOWNTO value DO                          
                        commands 
                  ENDFOR                                                     

                | READ identifier ';'                                                     

                | WRITE value ';'                                                       
;

expression:     value                 { $$ = $1; }                                                   
                | value PLUS value    { $$ = $1 + $3;}                                                
                | value MINUS value                                                      
                | value TIMES value                                                       
                | value DIV value                                                       
                | value MOD value                                                      
;

condition:      value EQ value                                                        
                | value NEQ value                                                     
                | value LE value                                                      
                | value GE value                                                      
                | value LEQ value                                                     
                | value GEQ value                                                     
;
  /*TODO probably might need MemBlock here later*/
value:          num                           { auto val = $1; code->loadValue(val); $$ = $1; }                                                 
                | identifier                  { auto index = $1; $$ = code->loadIdentifier(index); }                                                              
;

identifier:     pidentifier                           { auto pid = $1; $$ = vars->getIndexOfVar(*(pid)); }                                                
                | pidentifier '(' pidentifier ')'     { auto pid2 = $3; auto pid = $1; auto res = vars->getIndexOfVar(*pid2);
                                                          $$ = vars->getIndexOfArrayElement(*pid,res); }                                        
                | pidentifier '(' num ')'             { auto pid = $1; auto val = $3; $$ = vars->getIndexOfArrayElement(*pid,val); }                                       
;


%%

void yyerror(std::string err){
  std::cerr << err;
}

int main(int argc, char** argv) {

        yyparse();
        
        return 0;
}